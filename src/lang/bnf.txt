BNF of Cap's template language

           program: blocks 

            blocks: ( code-block | ref-block | text-block ) blocks
        code-block: '{@' elems '@}'
         ref-block: '{#' formula '#}'
        text-block: .*
             elems: ( def | stmt | formula ) elems

              stmt: import_stmt |
                    if_stmt |
                    for_stmt |
                    break_stmt |
                    continue_stmt |
                    return_stmt

               def: func_def 
          func_def: 'def' identifier func_def_params ':' elems 'end' |
                     'def' identifier func_def_params ':' '@}' blocks '{@' 'end' 
   func_def_params: '(' func_def_args ')'
     func_def_args: identifier ( ',' identifier )*

       import_stmt: 'import' identifier_chain ( '@} ' | NEWLINE )+

           if_stmt: 'if' test ':' elems* ( elif_stmt | else_stmt | 'end' ) |
                    'if' test ':' '@}' blocks* '{@' ( elif_stmt | else_stmt | 'end' )
         elif_stmt: 'elif' test ':' elems ( elif_stmt | else_stmt | 'end' ) |
                    'elif' test ':' '@}' blocks* '{@' ( elif_stmt | else_stmt | 'end' )
         else_stmt: 'else' ':' elems* 'end'* |
                    'else' ':' '@}' blocks* '{@' 'end'*

          for_stmt: 'for' init_formula ';' comp_formula ';' update_formula ':' elems 'end' |
                    'for' init_formula ';' comp_formula ';' update_formula ':' '@}' blocks '@}' 'end' |
                    'for' comp_formula ':' elems 'end' |
                    'for' comp_formula ':' '@}' blocks '{@' 'end' |
                    'for' ':' elems 'end' |
                    'for' ':' '@}' blocks '{@' 'end'
        break_stmt: 'break'
     continue_stmt: 'continue'
       return_stmt: 'return' ( formula )

           formula: assign_list |
                    multi_assign
      multi_assign: test_list ( '=' test_list )*
       assign_list: assign ( ',' assign )*
            assign: test '=' test ( '=' test )*
            
         test_list: test ( ',' test )*
              test: or_test
           or_test: and_test ( 'or' and_test )*
          and_test: not_test ( 'and' not_test )*
          not_test: 'not' not_test | comparison

        comparison: asscalc ( comp_op asscalc )*
           asscalc: expr ( augassign expr )*
              expr: term ( add_sub_op term )*
             term: factor ( mul_div_op factor )*
            factor: atom | '(' test ')'
              atom: nil |
                    false |
                    true |
                    digit |
                    string |
                    identifier |
                    caller

           comp_op: '==' | '!='
        add_sub_op: '+' | '-'
        mul_div_op: '*' | '/'
         augassign: '+=' | '-=' | '*=' | '/='
             digit: [0-9]+
           newline: '\n'
            caller: identifier_chain '(' test_list ')'
  identifier_chain: ( identifier | identifier '.' ) identifier_chain
            string: '"' .* '"'
        identifier: ( [a-z] | [0-9] | _ )+ 
