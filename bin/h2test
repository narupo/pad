#!/usr/bin/python3
# coding: utf-8
import sys
from stream import Stream

def isnewline(c):
    return c in '\n'

class Tokenizer():

    def __init__(self):
        self.name = ''
        self.m = None
        self.buf = ''
        self.tokens = []

    def clearbuf(self):
        self.buf = ''

    def addbuf(self, c):
        self.buf += c

    def pushbuf(self):
        if not len(self.buf):
            return
        self.tokens.append(self.buf)
        self.clearbuf()

    def pushchar(self, c):
        self.tokens.append(c)

    def debug_show(self):
        if False:
            print('"{0}": {1}'.format(self.s.cur().replace('\n', '\\n'), str(self.m).split(' ')[2]))

    def isidentifier(self, c):
        return c in '_' or c.isalnum() 

    def isspace(self, c):
        return c.isspace()

    def isdigit(self, c):
        return c.isdigit()

    def issinglechar(self, c):
        return c in '\t#[](){}.,;:+-*/%<>='

    def isnewline(self, c):
        return c in '\n'

    def previsnewline(self):
        if not len(self.tokens):
            return False
        return self.isnewline(self.tokens[-1])

    def parse(self, fin, name):
        self.name = name
        self.m = self.m0
        self.s = Stream(fin.read())
        self.clearbuf()
        self.tokens = []

        while not self.s.eof():
            self.debug_show()
            self.m()

        return list(self.tokens)

    def m0(self):
        c = self.s.get()
        if c in '"':
            self.m = self.m_dquote
            self.addbuf(c)
        elif self.isdigit(c):
            self.m = self.m_digit
        elif self.isidentifier(c):
            self.addbuf(c)
        elif c == '/' and self.s.cur() == '/':
            self.pushbuf()
            self.addbuf(c)
            self.addbuf(self.s.get())
            self.m = self.m_line_comment
        elif c == '/' and self.s.cur() == '*':
            self.pushbuf()
            self.addbuf(c)
            self.addbuf(self.s.get())
            self.m = self.m_block_comment
        elif c == '*' and self.s.cur() == '/':
            self.pushbuf()
            self.addbuf(c)
            self.addbuf(self.s.get())
            self.pushbuf()
        elif self.issinglechar(c):
            self.pushbuf()
            self.pushchar(c)
        elif self.isnewline(c):
            self.pushbuf()
            if not self.previsnewline():
                self.pushchar(c)
        elif self.isspace(c):
            self.pushbuf()

    def m_digit(self):
        c = self.s.get()
        if self.isdigit(c):
            self.addbuf(c)
        else:
            self.m = self.m0
            self.pushbuf()

    def m_dquote(self):
        """ '"' """
        c = self.s.get()
        if c in '"':
            self.addbuf(c)
            self.pushbuf()

    def m_line_comment(self):
        """ '//' """
        c = self.s.get()
        if c in '\n':
            self.addbuf(c)
            self.pushbuf()
            self.m = self.m0
        else:
            self.addbuf(c)

    def m_block_comment(self):
        """ '//' """
        c = self.s.get()
        if c in '*' and self.s.cur() == '/':
            self.addbuf(c)
            self.addbuf(self.s.get())
            self.pushbuf()
            self.m = self.m0
        else:
            self.addbuf(c)

def backtrace_funcname(toks, ofsidx):
    return toks[ofsidx]
    # funcname = ''
    # for i in range(ofsidx, 0, -1):
    #     t = toks[i]
    #     if t == '\n':
    #         break
    #     funcname = t + funcname 
    # return funcname

def f(toks, modulename):
    m = 0
    funcnames = []
    for i, t in enumerate(toks):
        # print('"{0}"'.format(t))
        if m == 0:
            if t == '#':
                m = 100
            elif t == '(':
                funcnames.append(backtrace_funcname(toks, i-1))
        elif m == 100:
            """ skip until newline """
            if t == '\n':
                m = 0

    for funcname in funcnames:
        print('static void\ntest_{module}_{func}(void) {{\n}}\n'.format(
            module=modulename,
            func=funcname.replace('cap_', ''),
        ))

    print('static const struct testcase\n{module}tests[] = {{'.format(
        module=modulename,
        )
    )
    for funcname in funcnames:
        print('\t{{"{func}", test_{module}_{func}}},'.format(
            module=modulename,
            func=funcname.replace('cap_', ''),
        ))
    print('\t{},')
    print('};')

def main(args):
    tkr = Tokenizer()
    toks = tkr.parse(sys.stdin, 'string')
    # print(toks)
    f(toks, 'file')
    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv))
